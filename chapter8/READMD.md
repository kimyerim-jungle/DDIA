# 8장:분산 시스템의 골칫거리

### 결함과 부분 장애

컴퓨터는 늘 같은 일을 한다

**부분 장애** : 분산 시스템에서 일부가 예측하지 못 한 방식으로 고장나는 것

부분 장애는 비결정적으로 발생한다.

(비결정적 : **어떤 상태가 아직 결정되지 않았거나 확실하지 않은 것)**

- 클라우드 컴퓨팅과 슈퍼 컴퓨팅

### 신뢰성 없는 네트워크

대부분 네트워크는 비동기 패킷 네트워크를 이용한다

요청을 보내고 응답을 기다릴 때, 반드시 요청/응답이 도착할 것이라고 확신할 수 없다

응답받지 못 할 경우, 원인을 아는 것은 불가능

- 현실의 네트워크 결함
    
    네트워크 결함은 언제든 일어날 수 있는 일이며, 소프트웨어가 네트워크 문제에 어떻게 대응할 지 정해야한다.
    
- 결함 감지
    
    시스템은 결함 있는 노드를 감지할 수 있어나 하나 네트워크의 불확실성 때문에 노드가 동작 중인지, 네트워크로 인한 결함인지 구별하기 어렵다
    
- 타임아웃과 기약 없는 지연
    
    비동기 네트워크는 기약 없는 지연이 있고, 합리적인 타임아웃 단위는 정하기가 어려운 문제다
    
    - 네트워크 혼잡과 큐 대기
        - 여러 노드가 동시에 같은 목적지로 패킷을 보내려 할 때, 네트워크 혼잡이 발생. 네트워크 동작에 문제가 없어도 대기중인 패킷이 많으면 유실되어 재전송이 필요할 수 있다.
        - 패킷이 목적지에 도착해도 CPU가 바쁘면 대기해야 한다.
        - 가상 환경의 운영체제는 다른 가상 장비가 CPU를 이용하는 동안 멈출 때가 흔하며, 네트워크 지연의 변동성이 더욱 증가된다.
        - TCP는 흐름 제어를 수행하여 네크워크 링크나 수신 노드에 과부하를 주지 않기 위해 송신율을 제한하기도 한다.
        
        고정된 타임아웃보다 지속적으로 변동성(jitter)를 측정하고 타임아웃을 조절하는 것이 좋다.
        
        **파이 증가 장애 감지기**, Akka(아카)와 카산드라가 사용하고, TCP도 비슷하게 동작
        
    - 동기 네트워크 vs 비동기 네크워크
        - 전화 네트워크 : 회선이 만들어져 고정된 대역폭이 할당된다. 동기식 네트워크로 ‘제한 있는 지연’이 보장된다.
        - 이더넷, IP : 큐 대기의 영향을 받는 패킷 교환 프로토콜로 ‘기약 없는 지연’이다. 가용한 네트워크 용량에 맞추어 데이터 전송률을 동적으로 조절하는 것으로 네트워크 용량을 낭비하지 않고, 전송을 최대한 빠르게 할 수 있다.
            - ATM : 하이브리드 네트워크를 만드려는 시도가 있었다.

### 신뢰성 없는 시계

애플리케이션은 **지속 시간 측정**과 **시점 측정**을 위해 시계에 의존한다.

분산 시스템은 통신이 즉각적이지 않아 네트워크의 지연과 각 개별 장비마다의 다른 시계로 인한 시간의 차이가 존재한다.

- 일 기준 시계, 단조 시계
    - 일 기준 시계 : 특정 달력에 따라 날짜와 시간을 반환한다. 리눅스의 clock_gettime()과 자바의 System.currentTimeMillis()가 있다. C#의 DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
    - 단조 시계 : 지속 시간 측정을 재는 데 적합. 단조 시계는 항상 앞으로 흐른다. 시계의 속도를 조정할 수는 있으나 앞, 뒤로 단위가 뛰게 할 수는 없다.
- 시계 동기화와 정확도
    - 일 기준 시계는 GPS, 정밀 시간 프로토콜 등으로 동기화를 진행할 수 있으며, 가능하면 외부 시간과 동기화되는 것이 유용하다.
- 동기화된 시계에 의존하기
    - 이벤트 순서화용 타임스탬프
        - 각 시계가 다를 경우, 타임스탬프로 의사를 결정할 때 문제가 발생할 수 있다. 이 문제는 **최종 쓰기 승리** 방식으로 해소한다. 같은 문제가 지속적으로 발생할 경우, 조용히 사라지는 데이터가 발생할 수 있다.
    - 시계 읽기는 신뢰구간이 있다
        - 스패너(Spanner)의 구글 트루타임 API는 타임스탬프 범위를 제공한다.
    - 전역 스냅숏용 동기화된 시계
        - 분산된 장비가 동일단 단조 증가 트랜잭션 ID를 갖는 것은 어렵다. 이때 동기화된 일 기준 시계의 타임스탬프를 ID로 사용할 수 있다.
- 프로세스 중단
    - 임차권
        
        어떤 노드가 리더로써 쓰기를 받아들일 때, 임차권이 있는 노드만 리더로 인정할 수 있다.
        
        이 노드는 주기적으로 임차권을 갱신해야 하며, 임차권이 만료될 경우에는 장애가 발생하여 갱신하지 못 한 것으로 간주한다.
        
        - 임차권을 로컬 시간으로 비교하는 것에 의존할 경우, 동기화되지 않은 시계 때문에 문제가 발생할 수 있고, 스레드가 오랜 시간 중단되었을 경우 리더 노드는 임차권이 만료된지 모르고 쓰기를 시도할 수 있다.
    - 응답 시간 보장
        - 엄격한 실시간 시스템 : 엄격한 환경에서는 소프트웨어가 응답해야하는 데드라인을 명시한다.
        - 실시간 시스템은 사용하는 도구를 제한하고, 실시간 응답이 중요하므로 고성능이 아닐 수 있다(처리량은 낮을 수 있다).
    - 가비지 컬렉션의 영향

### 지식, 진실, 그리고 거짓말

- 진실은 다수결로 결정된다
    - 리더와 잠금
        
        각 노드는 자신이 얻은 자원이 만료되었음을 모르고 행동하기도 한다
        
    - 펜싱 토큰
        
        잠금을 승인할 때 서버에서 펜싱 토큰을 함께 반환
        
    - 비잔틴 결함
        
        노드가 거짓말하여 생기는 결함
        
        비잔틴 결함에서 발생하는 문제에도 올바르게 동작하면 비잔틴 내결함성을 지녔다고 얘기한다.
        
        - 클라이언트가 공격을 받거나 오염된 응답을 할 수가 있다.
    - 약한 형태의 거짓말
        
        
- 시스템 모델과 현실
    - 시스템 모델 : 타이밍 가정
        - 동기식 모델 : 지연, 중단, 오차에 상한선이 있다고 가정하는 것.
        - 부분 동기식 모델 : 대부분 동기식 시스템처럼 동작하지만, 때로 상한선을 초과하는 지연, 중단이 발생하기도 함.
        - 비동기식 모델 : 타이밍에 대한 가정을 할 수 없는 모델. 비동기식 모델로 설계할 수 있는 알고리즘은 매우 제한적이다.
    - 시스템 모델 : 노드 장애
        - 죽으면 중단(crash-stop) : 노드에 장애가 발생해 중단되면 다시 돌아오지 않음
        - 죽으면 복구(crash-recovery) : 노드가 죽으면 일정 시간 이후에 다시 응답할 것으로 가정
        - 비잔틴(임의적인) 결함 : 다른 노드를 속이거나 기만하는 등 무엇이는 할 수도 있는 노드
    - 알고리즘의 정확성
        
        알고리즘이 정확하다는 것은 본인의 속성을 유지한다는 것이다.
        
    - 안전성과 활동성
        - 안정성이 위반되면 위반된 시점을 가리킬 수 있다. 그러나 위반된 속성을 복구할 수 없다. (유일성이 위반되어 중복된 토큰이 발생할 경우, 어떤 번호에서 중복되었는 지 확인할 수 있지만 토큰이 중복되기 이전 번호로 돌아갈 수는 없다)
        - 활동성이 위반되면 위반된 시점을 확정하지 못 할 수도 있지만, 해당 속성이 언젠가 만족될 수 있다는 희망을 갖는다.
    - 시스템 모델을 현실 세계에 대응시키기
        - 이론적으로 설계하는 모델로 현실에서도 발생할 수 있는 문제를 추론하고 해결하도록 노력할 수 있다.
        - 알고리즘이 올바르다고 증명되어도 현실에서 언제나 올바르게 동작하는 것은 아니다. 그럼에도 이론적 분석은 중요하다.

### 정리

**분산 시스템의 특성 : 부분 실패가 생길 수 있다**

부분 실패에 대한 감지와 결함에 대한 대책이 필요하다.